% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/af_filter.R
\name{af_filter}
\alias{af_filter}
\title{Allele frequency filter}
\usage{
af_filter(x1, n1, x2, n2, bim)
}
\arguments{
\item{x1}{The number of alleles of one type in the first dataset.}

\item{n1}{The total numbers of alleles (of all types) in the first dataset.}

\item{x2}{The number of alleles of one type in the second dataset.}

\item{n2}{The total numbers of alleles (of all types) in the second dataset.}

\item{bim}{Locus annotation table, containing minimally two columns named \code{ref} and \code{alt} with the two alleles at that locus (such as "A" and "G", or "TGT" and "T").}
}
\value{
The input \code{bim} table with the following three columns added:
\itemize{
\item \code{revcomp}: Logical, whether locus is identified as having reverse complement (flippale) alleles.
\item \code{pval_fwd}: p-values from \code{\link[=af_test]{af_test()}} in given orientation.
\item \code{pval_rev}: p-values from \code{\link[=af_test]{af_test()}} in reversed orientation for the second dataset, for loci with \code{revcomp == TRUE}.  Rest of loci have \code{NA} p-values.
}
}
\description{
This applies the AF-filter, which is a wrapper around \code{\link[=af_test]{af_test()}} that tests whether allele frequencies match in the given orientation between two datasets, then identifies flippable (reverse complement) loci and also tests them in the reverse orientation in the second dataset.
This function returns the input locus info table with the two sets of p-values, as applicable.
However, no thresholds or classification results are applied here, for that see another function.
}
\examples{
# data with three loci, two ancestries, two datasets
# make our minimal BIM table of locus annotations
# note last three are reverse complement ref/alt pairs
bim <- data.frame(
  ref = c('A', 'G', 'C', 'T', 'G'),
  alt = c('G', 'T', 'G', 'A', 'C')
)
m_loci <- nrow( bim )
k_subpops <- 2
# all same sample size with no missingness for simplicity
n <- 10
# and same allele frequency in this case
p <- 0.5
# the actual data we need as input
n1 <- matrix( n, nrow = m_loci, ncol = k_subpops )
n2 <- n1
x1 <- matrix(
  rbinom( m_loci * k_subpops, n, p ),
  nrow = m_loci, ncol = k_subpops
)
x2 <- matrix(
  rbinom( m_loci * k_subpops, n, p ),
  nrow = m_loci, ncol = k_subpops
)

# apply function, get desired p-values!
data <- af_filter( x1, n1, x2, n2, bim )

}
\seealso{
\code{\link[=af_test]{af_test()}} for the association test based on allele frequencies/counts.

\code{\link[=revcomp]{revcomp()}} for determining reverse complements.
}
